#!/usr/bin/env python3
"""
Cleanup utility for test/demo artifacts.

This tool safely removes test and demo artifacts created during local runs and CI.
It operates in dry-run mode by default and requires explicit flags for actual deletion.

Usage:
    python tools/cleanup_test_artifacts.py --include-sample-test --pattern 'tmp*'
    python tools/cleanup_test_artifacts.py --include-sample-test --pattern 'tmp*' --really-delete --yes
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Dict, List, Tuple, Any
import fnmatch
from datetime import datetime


def load_run_index() -> Dict[str, Any]:
    """Load the run index file."""
    index_path = Path("data/run_index.json")
    if not index_path.exists():
        return {}

    try:
        with open(index_path, "r") as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError) as e:
        print(f"Warning: Could not load run index: {e}")
        return {}


def save_run_index(run_index: Dict[str, Any]) -> None:
    """Save the run index file atomically."""
    index_path = Path("data/run_index.json")
    temp_path = index_path.with_suffix(".tmp")

    try:
        with open(temp_path, "w") as f:
            json.dump(run_index, f, indent=2)
        temp_path.replace(index_path)
    except IOError as e:
        print(f"Error: Could not save run index: {e}")
        if temp_path.exists():
            temp_path.unlink()


def is_temporary_filename(filename: str) -> bool:
    """Check if a filename looks temporary."""
    basename = Path(filename).name.lower()
    return (
        basename.startswith("tmp")
        or basename.startswith("temp")
        or basename.startswith("test_")
        or basename.endswith("_test.csv")
        or basename.endswith("_temp.csv")
        or basename.endswith("_tmp.csv")
    )


def is_sample_test_run(run_data: Dict[str, Any]) -> bool:
    """Check if a run was generated by sample_test.csv."""
    input_paths = run_data.get("input_paths", [])
    return any("sample_test.csv" in str(path) for path in input_paths)


def is_stale_run(run_id: str, run_data: Dict[str, Any]) -> bool:
    """Check if a run directory no longer exists."""
    interim_dir = Path(f"data/interim/{run_id}")
    processed_dir = Path(f"data/processed/{run_id}")
    return not interim_dir.exists() and not processed_dir.exists()


def get_run_age_days(run_data: Dict[str, Any]) -> int:
    """Get the age of a run in days."""
    timestamp_str = run_data.get("timestamp", "")
    if not timestamp_str:
        return 999  # Very old if no timestamp

    try:
        # Parse ISO format timestamp
        run_time = datetime.fromisoformat(timestamp_str.replace("Z", "+00:00"))
        age = datetime.now(run_time.tzinfo) - run_time
        return age.days
    except (ValueError, TypeError):
        return 999  # Very old if parsing fails


def find_candidate_runs(
    run_index: Dict[str, Any],
    pattern: str = None,
    include_sample_test: bool = False,
    days_older_than: int = None,
    only_stale_index: bool = False,
) -> List[Tuple[str, Dict[str, Any], str]]:
    """
    Find runs that match cleanup criteria.

    Returns:
        List of (run_id, run_data, reason) tuples
    """
    candidates = []

    for run_id, run_data in run_index.items():
        reason = None

        # Check for stale index entries
        if only_stale_index or is_stale_run(run_id, run_data):
            reason = "stale_index"

        # Check for sample test runs
        elif include_sample_test and is_sample_test_run(run_data):
            reason = "sample_test"

        # Check for temporary filename patterns
        elif pattern:
            input_paths = run_data.get("input_paths", [])
            for path in input_paths:
                if fnmatch.fnmatch(str(path), pattern):
                    reason = "pattern_match"
                    break

        # Check for temporary filenames (without pattern)
        elif not pattern and not include_sample_test and not only_stale_index:
            input_paths = run_data.get("input_paths", [])
            for path in input_paths:
                if is_temporary_filename(str(path)):
                    reason = "temporary_filename"
                    break

        # Check for age
        if reason and days_older_than:
            age_days = get_run_age_days(run_data)
            if age_days < days_older_than:
                reason = None  # Too young

        if reason:
            candidates.append((run_id, run_data, reason))

    return candidates


def delete_run_directories(run_id: str) -> bool:
    """Delete run directories safely."""
    success = True

    # Delete interim directory
    interim_dir = Path(f"data/interim/{run_id}")
    if interim_dir.exists():
        try:
            import shutil

            shutil.rmtree(interim_dir)
        except OSError as e:
            print(f"Warning: Could not delete {interim_dir}: {e}")
            success = False

    # Delete processed directory
    processed_dir = Path(f"data/processed/{run_id}")
    if processed_dir.exists():
        try:
            import shutil

            shutil.rmtree(processed_dir)
        except OSError as e:
            print(f"Warning: Could not delete {processed_dir}: {e}")
            success = False

    return success


def update_latest_symlink() -> None:
    """Update the latest symlink if it points to a deleted run."""
    latest_path = Path("data/processed/latest")
    if not latest_path.exists() or not latest_path.is_symlink():
        return

    try:
        target = latest_path.resolve()
        if not target.exists():
            # Latest symlink points to non-existent directory
            latest_path.unlink()
            print("Removed stale latest symlink")
    except OSError:
        # Symlink is broken
        latest_path.unlink()
        print("Removed broken latest symlink")


def main() -> int:
    """Main cleanup function."""
    parser = argparse.ArgumentParser(
        description="Clean up test and demo artifacts safely",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Dry-run: list candidates created by tests/tmp inputs
  python tools/cleanup_test_artifacts.py --include-sample-test --pattern 'tmp*'

  # Actually delete candidates after review (explicit fuse)
  python tools/cleanup_test_artifacts.py --include-sample-test --pattern 'tmp*' --really-delete --yes

  # Prune only stale index entries (no file deletes)
  python tools/cleanup_test_artifacts.py --only-stale-index --really-delete --yes
        """,
    )

    parser.add_argument(
        "--pattern", help="Glob pattern to match input filenames (e.g., 'tmp*')"
    )
    parser.add_argument(
        "--include-sample-test",
        action="store_true",
        help="Include runs generated by sample_test.csv",
    )
    parser.add_argument(
        "--days-older-than", type=int, help="Only consider runs older than N days"
    )
    parser.add_argument(
        "--only-stale-index",
        action="store_true",
        help="Only remove stale index entries (no file deletion)",
    )
    parser.add_argument(
        "--really-delete",
        action="store_true",
        help="Actually delete files (default is dry-run)",
    )
    parser.add_argument("--yes", action="store_true", help="Skip confirmation prompts")

    args = parser.parse_args()

    # Validate arguments
    if not any(
        [
            args.pattern,
            args.include_sample_test,
            args.days_older_than,
            args.only_stale_index,
        ]
    ):
        print("Error: Must specify at least one filter criterion")
        print("Use --help for usage information")
        return 1

    # Load run index
    run_index = load_run_index()
    if not run_index:
        print("No runs found in index")
        return 0

    # Find candidates
    candidates = find_candidate_runs(
        run_index,
        pattern=args.pattern,
        include_sample_test=args.include_sample_test,
        days_older_than=args.days_older_than,
        only_stale_index=args.only_stale_index,
    )

    if not candidates:
        print("No candidates found matching criteria")
        return 0

    # Print summary
    print(f"Found {len(candidates)} candidate(s) for cleanup:")
    for run_id, run_data, reason in candidates:
        input_paths = run_data.get("input_paths", [])
        age_days = get_run_age_days(run_data)
        print(
            f"  {run_id} ({reason}) - {input_paths[0] if input_paths else 'no input'} - {age_days} days old"
        )

    # Check for interactive confirmation
    if args.really_delete and not args.yes and sys.stdin.isatty():
        print(f"\nAbout to delete {len(candidates)} run(s)")
        response = input("Continue? (y/N): ")
        if response.lower() not in ["y", "yes"]:
            print("Aborted")
            return 1

    # Execute cleanup
    deleted_runs = []
    pruned_index_count = 0

    if args.really_delete:
        print(f"\nDeleting {len(candidates)} run(s)...")

        for run_id, run_data, reason in candidates:
            if reason == "stale_index" or args.only_stale_index:
                # Only remove from index
                del run_index[run_id]
                pruned_index_count += 1
                print(f"  Removed stale index entry: {run_id}")
            else:
                # Delete directories and remove from index
                if delete_run_directories(run_id):
                    del run_index[run_id]
                    deleted_runs.append(run_id)
                    print(f"  Deleted: {run_id}")
                else:
                    print(f"  Failed to delete: {run_id}")

        # Update latest symlink if needed
        if not args.only_stale_index:
            update_latest_symlink()

        # Save updated index
        save_run_index(run_index)

    # Print summary
    summary = {
        "dry_run": not args.really_delete,
        "scanned": len(run_index),
        "candidates": [run_id for run_id, _, _ in candidates],
        "deleted": deleted_runs,
        "pruned_index": pruned_index_count,
    }

    print(f"\nSummary: {json.dumps(summary, indent=2)}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
