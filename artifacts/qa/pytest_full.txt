FFFFF.F.......FF.FFFF.....EEEEEEEEEE.....F...............ss............. [  8%]
.................ssssssssss.......F..................................... [ 17%]
...........................FFFFFF.............F.FF........FF............ [ 26%]
.....................FF.F.FF..ssss...................................... [ 35%]
..............F.F..FF.........................F.........F.F...F......... [ 44%]
..............F......................................................... [ 53%]
....................................FF..F.FF........................sss. [ 62%]
........................................................................ [ 71%]
........................................................................ [ 80%]
........................................................................ [ 88%]
..F..................................................................... [ 97%]
.................                                                        [100%]
==================================== ERRORS ====================================
___ ERROR at setup of TestGroupsPageBenchmarks.test_groups_page_10k_pyarrow ____
file /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py, line 208
      @pytest.mark.performance
      def test_groups_page_10k_pyarrow(self, benchmark, synthetic_10k_paths, monkeypatch):
E       fixture 'benchmark' not found
>       available fixtures: cache, cache_utils_workspace, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, enable_destructive_fuse, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, settings_from_config, synthetic_100k_data, synthetic_100k_paths, synthetic_10k_data, synthetic_10k_paths, synthetic_1m_data, synthetic_1m_paths, temp_workspace, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:208
____ ERROR at setup of TestGroupsPageBenchmarks.test_groups_page_10k_duckdb ____
file /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py, line 234
      @pytest.mark.performance
      def test_groups_page_10k_duckdb(self, benchmark, synthetic_10k_paths, monkeypatch):
E       fixture 'benchmark' not found
>       available fixtures: cache, cache_utils_workspace, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, enable_destructive_fuse, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, settings_from_config, synthetic_100k_data, synthetic_100k_paths, synthetic_10k_data, synthetic_10k_paths, synthetic_1m_data, synthetic_1m_paths, temp_workspace, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:234
___ ERROR at setup of TestGroupsPageBenchmarks.test_groups_page_100k_pyarrow ___
file /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py, line 261
      @pytest.mark.performance
      def test_groups_page_100k_pyarrow(
E       fixture 'benchmark' not found
>       available fixtures: cache, cache_utils_workspace, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, enable_destructive_fuse, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, settings_from_config, synthetic_100k_data, synthetic_100k_paths, synthetic_10k_data, synthetic_10k_paths, synthetic_1m_data, synthetic_1m_paths, temp_workspace, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:261
___ ERROR at setup of TestGroupsPageBenchmarks.test_groups_page_100k_duckdb ____
file /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py, line 289
      @pytest.mark.performance
      def test_groups_page_100k_duckdb(
E       fixture 'benchmark' not found
>       available fixtures: cache, cache_utils_workspace, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, enable_destructive_fuse, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, settings_from_config, synthetic_100k_data, synthetic_100k_paths, synthetic_10k_data, synthetic_10k_paths, synthetic_1m_data, synthetic_1m_paths, temp_workspace, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:289
____ ERROR at setup of TestGroupsPageBenchmarks.test_groups_page_1m_pyarrow ____
file /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py, line 317
      @pytest.mark.performance
      @pytest.mark.slow
      def test_groups_page_1m_pyarrow(self, benchmark, synthetic_1m_paths, monkeypatch):
E       fixture 'benchmark' not found
>       available fixtures: cache, cache_utils_workspace, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, enable_destructive_fuse, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, settings_from_config, synthetic_100k_data, synthetic_100k_paths, synthetic_10k_data, synthetic_10k_paths, synthetic_1m_data, synthetic_1m_paths, temp_workspace, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:317
____ ERROR at setup of TestGroupsPageBenchmarks.test_groups_page_1m_duckdb _____
file /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py, line 344
      @pytest.mark.performance
      @pytest.mark.slow
      def test_groups_page_1m_duckdb(self, benchmark, synthetic_1m_paths, monkeypatch):
E       fixture 'benchmark' not found
>       available fixtures: cache, cache_utils_workspace, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, enable_destructive_fuse, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, settings_from_config, synthetic_100k_data, synthetic_100k_paths, synthetic_10k_data, synthetic_10k_paths, synthetic_1m_data, synthetic_1m_paths, temp_workspace, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:344
_ ERROR at setup of TestGroupDetailsBenchmarks.test_group_details_10k_pyarrow __
file /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py, line 375
      @pytest.mark.performance
      def test_group_details_10k_pyarrow(
E       fixture 'benchmark' not found
>       available fixtures: cache, cache_utils_workspace, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, enable_destructive_fuse, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, settings_from_config, synthetic_100k_data, synthetic_100k_paths, synthetic_10k_data, synthetic_10k_paths, synthetic_1m_data, synthetic_1m_paths, temp_workspace, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:375
__ ERROR at setup of TestGroupDetailsBenchmarks.test_group_details_10k_duckdb __
file /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py, line 404
      @pytest.mark.performance
      def test_group_details_10k_duckdb(
E       fixture 'benchmark' not found
>       available fixtures: cache, cache_utils_workspace, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, enable_destructive_fuse, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, settings_from_config, synthetic_100k_data, synthetic_100k_paths, synthetic_10k_data, synthetic_10k_paths, synthetic_1m_data, synthetic_1m_paths, temp_workspace, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:404
__________ ERROR at setup of TestSortVariants.test_sort_variants_10k ___________
file /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py, line 437
      @pytest.mark.performance
      def test_sort_variants_10k(self, benchmark, synthetic_10k_paths, monkeypatch):
E       fixture 'benchmark' not found
>       available fixtures: cache, cache_utils_workspace, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, enable_destructive_fuse, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, settings_from_config, synthetic_100k_data, synthetic_100k_paths, synthetic_10k_data, synthetic_10k_paths, synthetic_1m_data, synthetic_1m_paths, temp_workspace, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:437
________ ERROR at setup of TestFilterVariants.test_filter_variants_10k _________
file /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py, line 472
      @pytest.mark.performance
      def test_filter_variants_10k(self, benchmark, synthetic_10k_paths, monkeypatch):
E       fixture 'benchmark' not found
>       available fixtures: cache, cache_utils_workspace, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, enable_destructive_fuse, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, settings_from_config, synthetic_100k_data, synthetic_100k_paths, synthetic_10k_data, synthetic_10k_paths, synthetic_1m_data, synthetic_1m_paths, temp_workspace, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:472
=================================== FAILURES ===================================
_______________ TestParquetContracts.test_required_columns_exist _______________

self = <tests.contracts.test_parquet_contracts.TestParquetContracts object at 0x108742990>
artifact_paths = {'group_details_parquet': '/path/to/group_details.parquet', 'group_stats_parquet': '/path/to/group_stats.parquet', 'review_ready_parquet': '/path/to/review_ready.parquet'}

    def test_required_columns_exist(self, artifact_paths):
        """Test that all required columns exist in parquet files."""
        for parquet_type, required in REQUIRED_COLUMNS.items():
            if parquet_type in artifact_paths:
                file_path = artifact_paths[parquet_type]
                result = validate_parquet_schema(file_path, parquet_type)
    
                assert result["valid"], (
                    f"{parquet_type} schema validation failed: {result['error']}\n"
                    f"Required: {required}\n"
>                   f"Actual: {result['actual_columns']}\n"
                               ^^^^^^^^^^^^^^^^^^^^^^^^
                    f"Missing: {result['missing_columns']}"
                )
E               KeyError: 'actual_columns'

tests/contracts/test_parquet_contracts.py:145: KeyError
_________________ TestParquetContracts.test_schema_consistency _________________

self = <tests.contracts.test_parquet_contracts.TestParquetContracts object at 0x1087598b0>
artifact_paths = {'group_details_parquet': '/path/to/group_details.parquet', 'group_stats_parquet': '/path/to/group_stats.parquet', 'review_ready_parquet': '/path/to/review_ready.parquet'}

    def test_schema_consistency(self, artifact_paths):
        """Test that schemas are consistent across runs."""
        # This test would compare schemas across multiple runs
        # For now, just ensure we can read the schema
        for parquet_type in REQUIRED_COLUMNS:
            if parquet_type in artifact_paths:
                file_path = artifact_paths[parquet_type]
                result = validate_parquet_schema(file_path, parquet_type)
    
>               assert result["valid"], f"Schema validation failed for {parquet_type}"
E               AssertionError: Schema validation failed for review_ready_parquet
E               assert False

tests/contracts/test_parquet_contracts.py:158: AssertionError
____________________ TestParquetContracts.test_column_types ____________________

self = <tests.contracts.test_parquet_contracts.TestParquetContracts object at 0x1053db7a0>
artifact_paths = {'group_details_parquet': '/path/to/group_details.parquet', 'group_stats_parquet': '/path/to/group_stats.parquet', 'review_ready_parquet': '/path/to/review_ready.parquet'}

    def test_column_types(self, artifact_paths):
        """Test that column types are as expected."""
        expected_types = {
            "group_id": "string",
            "account_name": "string",
            "is_primary": "bool",
            "disposition": "string",
            "group_size": "int64",
            "max_score": "double",
            "primary_name": "string",
            "weakest_edge_to_primary": "double",
        }
    
        for parquet_type in REQUIRED_COLUMNS:
            if parquet_type in artifact_paths:
                file_path = artifact_paths[parquet_type]
                result = validate_parquet_schema(file_path, parquet_type)
    
>               assert result["valid"], f"Schema validation failed for {parquet_type}"
E               AssertionError: Schema validation failed for review_ready_parquet
E               assert False

tests/contracts/test_parquet_contracts.py:179: AssertionError
_____________ TestParquetContracts.test_no_extra_required_columns ______________

self = <tests.contracts.test_parquet_contracts.TestParquetContracts object at 0x1053da840>
artifact_paths = {'group_details_parquet': '/path/to/group_details.parquet', 'group_stats_parquet': '/path/to/group_stats.parquet', 'review_ready_parquet': '/path/to/review_ready.parquet'}

    def test_no_extra_required_columns(self, artifact_paths):
        """Test that we don't have unexpected required columns."""
        # This ensures our contract is not too strict
        for parquet_type in REQUIRED_COLUMNS:
            if parquet_type in artifact_paths:
                file_path = artifact_paths[parquet_type]
                result = validate_parquet_schema(file_path, parquet_type)
    
>               assert result["valid"], f"Schema validation failed for {parquet_type}"
E               AssertionError: Schema validation failed for review_ready_parquet
E               assert False

tests/contracts/test_parquet_contracts.py:211: AssertionError
_________________ TestParquetContracts.test_contract_evolution _________________

self = <tests.contracts.test_parquet_contracts.TestParquetContracts object at 0x10403f470>
artifact_paths = {'group_details_parquet': '/path/to/group_details.parquet', 'group_stats_parquet': '/path/to/group_stats.parquet', 'review_ready_parquet': '/path/to/review_ready.parquet'}

    def test_contract_evolution(self, artifact_paths):
        """Test that contracts can evolve safely."""
        # This test documents how to safely evolve contracts
        for parquet_type in REQUIRED_COLUMNS:
            if parquet_type in artifact_paths:
                file_path = artifact_paths[parquet_type]
                result = validate_parquet_schema(file_path, parquet_type)
    
>               assert result["valid"], f"Schema validation failed for {parquet_type}"
E               AssertionError: Schema validation failed for review_ready_parquet
E               assert False

tests/contracts/test_parquet_contracts.py:230: AssertionError
______ TestHardcodedColumnAssumptions.test_detect_schema_constants_usage _______

self = <tests.contracts.test_parquet_contracts.TestHardcodedColumnAssumptions object at 0x108788a40>

    def test_detect_schema_constants_usage(self):
        """Test that schema constants are used consistently."""
        # Check that DETAILS_COLUMNS and similar constants are defined and used
        src_dir = Path(__file__).parent.parent.parent / "src"
        utils_dir = src_dir / "utils"
    
        schema_files = []
        for py_file in utils_dir.rglob("*.py"):
            try:
                with open(py_file) as f:
                    content = f.read()
    
                # Look for column constant definitions
                if "DETAILS_COLUMNS" in content or "GROUP_STATS_COLUMNS" in content:
                    schema_files.append(py_file)
    
            except Exception:
                continue
    
        # Ensure we have schema constant definitions
        assert len(schema_files) > 0, "No schema constant definitions found in utils/"
    
        # Check that constants are used consistently
        for schema_file in schema_files:
            try:
                with open(schema_file) as f:
                    content = f.read()
    
                # Look for hardcoded column lists that should use constants
                if (
                    "[" in content
                    and "GROUP_ID" in content
                    and "ACCOUNT_NAME" in content
                ):
                    # This is a potential hardcoded list - check if it's in a constant definition
                    lines = content.split("\n")
                    for i, line in enumerate(lines):
                        if (
                            "[" in line
                            and "GROUP_ID" in line
                            and "ACCOUNT_NAME" in line
                        ):
                            # Check if this line defines a constant
                            if "=" in line and (
                                "DETAILS_COLUMNS" in line
                                or "GROUP_STATS_COLUMNS" in line
                            ):
                                continue  # This is a constant definition, which is OK
>                           pytest.fail(
                                f"Potential hardcoded column list in {schema_file}:{i+1}\n"
                                f"Line: {line.strip()}\n"
                                f"Consider using a schema constant instead.",
                            )
E                           Failed: Potential hardcoded column list in /Users/joe.j/Documents/dev/salesforce/apps/company_junction/src/utils/group_details.py:98
E                           Line: return [GROUP_ID, ACCOUNT_NAME, DISPOSITION]
E                           Consider using a schema constant instead.

tests/contracts/test_parquet_contracts.py:339: Failed
_____ TestLegacyColumnHandling.test_duckdb_handles_present_legacy_columns ______

self = <tests.contracts.test_parquet_contracts.TestLegacyColumnHandling object at 0x1087895b0>
sample_data_with_legacy_columns = pyarrow.Table
group_id: string
account_id: string
account_name: string
suffix_class: string
created_date: string
dispo...
disposition: [["Keep","Update","Delete"]]
is_primary: [[true,false,false]]
weakest_edge_to_primary: [[0.95,0.85,0.75]]

    def test_duckdb_handles_present_legacy_columns(
        self, sample_data_with_legacy_columns,
    ):
        """Test that DuckDB backend works with present legacy columns."""
        with tempfile.NamedTemporaryFile(suffix=".parquet", delete=False) as tmp_file:
            pq.write_table(sample_data_with_legacy_columns, tmp_file.name)
    
            try:
                import duckdb
    
                conn = duckdb.connect()
    
                # Test filtering by min_edge_strength (should work with legacy columns)
                result = conn.execute(
                    f"""
                    SELECT * FROM read_parquet('{tmp_file.name}')
                    WHERE weakest_edge_to_primary >= 0.8
                """,
                ).fetchall()
>               assert len(result) == 3
E               AssertionError: assert 2 == 3
E                +  where 2 = len([('group1', 'acc1', 'Company A', 'INC', '2023-01-01', 'Keep', ...), ('group2', 'acc2', 'Company B', 'LLC', '2023-01-02', 'Update', ...)])

tests/contracts/test_parquet_contracts.py:519: AssertionError
_____ TestLegacyColumnHandling.test_pyarrow_handles_present_legacy_columns _____

self = <tests.contracts.test_parquet_contracts.TestLegacyColumnHandling object at 0x108789790>
sample_data_with_legacy_columns = pyarrow.Table
group_id: string
account_id: string
account_name: string
suffix_class: string
created_date: string
dispo...
disposition: [["Keep","Update","Delete"]]
is_primary: [[true,false,false]]
weakest_edge_to_primary: [[0.95,0.85,0.75]]

    def test_pyarrow_handles_present_legacy_columns(
        self, sample_data_with_legacy_columns,
    ):
        """Test that PyArrow backend works with present legacy columns."""
        with tempfile.NamedTemporaryFile(suffix=".parquet", delete=False) as tmp_file:
            pq.write_table(sample_data_with_legacy_columns, tmp_file.name)
    
            try:
                table = pq.read_table(tmp_file.name)
                assert table.num_rows == 3
    
                # Test filtering by min_edge_strength (should work with legacy columns)
                filtered = table.filter(
                    pa.compute.greater_equal(
                        table["weakest_edge_to_primary"], pa.scalar(0.8),
                    ),
                )
>               assert filtered.num_rows == 3
E               assert 2 == 3
E                +  where 2 = pyarrow.Table\ngroup_id: string\naccount_id: string\naccount_name: string\nsuffix_class: string\ncreated_date: string\ndispo...1-01","2023-01-02"]]\ndisposition: [["Keep","Update"]]\nis_primary: [[true,false]]\nweakest_edge_to_primary: [[0.95,0.85]].num_rows

tests/contracts/test_parquet_contracts.py:552: AssertionError
_ TestLegacyColumnHandling.test_conditional_filtering_works_with_present_columns _

self = <tests.contracts.test_parquet_contracts.TestLegacyColumnHandling object at 0x1053da9f0>
sample_data_with_legacy_columns = pyarrow.Table
group_id: string
account_id: string
account_name: string
suffix_class: string
created_date: string
dispo...
disposition: [["Keep","Update","Delete"]]
is_primary: [[true,false,false]]
weakest_edge_to_primary: [[0.95,0.85,0.75]]

    def test_conditional_filtering_works_with_present_columns(
        self, sample_data_with_legacy_columns,
    ):
        """Test that conditional filtering works when columns are present."""
        with tempfile.NamedTemporaryFile(suffix=".parquet", delete=False) as tmp_file:
            pq.write_table(sample_data_with_legacy_columns, tmp_file.name)
    
            try:
                # Test the conditional filtering logic
                from src.utils.filtering import apply_filters_pyarrow
    
                # Get available columns
                table = pq.read_table(tmp_file.name)
                available_columns = table.column_names
    
                # Test filtering with min_edge_strength (should work with legacy columns)
                filters = {"min_edge_strength": 0.8}
>               filtered = apply_filters_pyarrow(table, filters, available_columns)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/contracts/test_parquet_contracts.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/filtering.py:155: in apply_filters_pyarrow
    es_mask = pc.greater_equal(
/Users/joe.j/.pyenv/versions/3.12.2/lib/python3.12/site-packages/pyarrow/compute.py:252: in wrapper
    return func.call(args, None, memory_pool)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pyarrow/_compute.pyx:386: in pyarrow._compute.Function.call
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   TypeError: Got unexpected argument type <class 'pyarrow._compute.Expression'> for compute function

pyarrow/_compute.pyx:519: TypeError
_ TestNoSchemaFragileHardcoding.test_no_hardcoded_primary_name_in_details_context _

self = <tests.lints.test_no_schema_fragile_hardcoding.TestNoSchemaFragileHardcoding object at 0x108789d60>

    def test_no_hardcoded_primary_name_in_details_context(self):
        """Test that group_details context doesn't use hardcoded primary_name."""
        project_root = Path(__file__).parent.parent.parent
        details_files = [
            project_root / "src" / "utils" / "group_details.py",
            project_root / "app" / "components" / "group_details.py",
        ]
    
        violations = []
    
        for file_path in details_files:
            if not file_path.exists():
                continue
    
            references = self.find_fragile_references(file_path)
            for line_num, line_content in references:
                # Check for hardcoded primary_name usage that should use context-aware functions
                if (
                    "primary_name" in line_content.lower()
                    and "context" not in line_content
                ):
                    violations.append(
                        f"{file_path.relative_to(project_root)}:{line_num} - {line_content}",
                    )
    
        if violations:
>           pytest.fail(
                f"Found {len(violations)} hardcoded primary_name references in details context:\n"
                + "\n".join(violations)
                + "\n\nUse get_order_by(sort_key, context='group_details') or build_sort_expression(sort_key, context='group_details') instead.",
            )
E           Failed: Found 2 hardcoded primary_name references in details context:
E           app/components/group_details.py:67 - primary_name,
E           app/components/group_details.py:79 - primary_name,
E           
E           Use get_order_by(sort_key, context='group_details') or build_sort_expression(sort_key, context='group_details') instead.

tests/lints/test_no_schema_fragile_hardcoding.py:160: Failed
_ TestNoSchemaFragileHardcoding.test_no_hardcoded_weakest_edge_without_availability_check _

self = <tests.lints.test_no_schema_fragile_hardcoding.TestNoSchemaFragileHardcoding object at 0x108789fa0>

    def test_no_hardcoded_weakest_edge_without_availability_check(self):
        """Test that WEAKEST_EDGE_TO_PRIMARY is not used without availability checks."""
        project_root = Path(__file__).parent.parent.parent
        search_dirs = ["src/utils", "app/components"]
    
        violations = []
    
        for dir_name in search_dirs:
            dir_path = project_root / dir_name
            if not dir_path.exists():
                continue
    
            for file_path in dir_path.rglob("*.py"):
                if self.should_exclude_file(file_path):
                    continue
    
                references = self.find_fragile_references(file_path)
                for line_num, line_content in references:
                    # Check for WEAKEST_EDGE_TO_PRIMARY usage without availability checks
                    if "WEAKEST_EDGE_TO_PRIMARY" in line_content:
                        if not any(
                            pattern in line_content
                            for pattern in [
                                "available_columns",
                                "in.*available_columns",
                                "is.*None.*or",
                                "context=",
                                "get_order_by",
                                "build_sort_expression",
                                "_build_where_clause",
                                "apply_filters_pyarrow",
                            ]
                        ):
                            violations.append(
                                f"{file_path.relative_to(project_root)}:{line_num} - {line_content}",
                            )
    
        if violations:
>           pytest.fail(
                f"Found {len(violations)} WEAKEST_EDGE_TO_PRIMARY references without availability checks:\n"
                + "\n".join(violations)
                + "\n\nUse conditional filtering with available_columns or context-aware functions.",
            )
E           Failed: Found 10 WEAKEST_EDGE_TO_PRIMARY references without availability checks:
E           src/utils/filtering.py:17 - WEAKEST_EDGE_TO_PRIMARY,
E           src/utils/filtering.py:156 - table[WEAKEST_EDGE_TO_PRIMARY], pc.scalar(float(min_es)),
E           src/utils/group_details.py:43 - WEAKEST_EDGE_TO_PRIMARY,
E           src/utils/group_details.py:124 - where_sql.append(WEAKEST_EDGE_TO_PRIMARY + " >= ?")
E           src/utils/group_pagination.py:28 - WEAKEST_EDGE_TO_PRIMARY,
E           src/utils/group_pagination.py:584 - WEAKEST_EDGE_TO_PRIMARY,
E           src/utils/group_pagination.py:595 - stats_select += f", MAX({WEAKEST_EDGE_TO_PRIMARY}) AS {MAX_SCORE}"
E           app/components/group_details.py:19 - WEAKEST_EDGE_TO_PRIMARY,
E           app/components/group_details.py:272 - WEAKEST_EDGE_TO_PRIMARY,
E           app/components/group_details.py:317 - WEAKEST_EDGE_TO_PRIMARY: st.column_config.NumberColumn(
E           
E           Use conditional filtering with available_columns or context-aware functions.

tests/lints/test_no_schema_fragile_hardcoding.py:204: Failed
_ TestNoSchemaFragileHardcoding.test_no_hardcoded_is_primary_without_availability_check _

self = <tests.lints.test_no_schema_fragile_hardcoding.TestNoSchemaFragileHardcoding object at 0x10878a120>

    def test_no_hardcoded_is_primary_without_availability_check(self):
        """Test that IS_PRIMARY is not used without availability checks."""
        project_root = Path(__file__).parent.parent.parent
        search_dirs = ["src/utils", "app/components"]
    
        violations = []
    
        for dir_name in search_dirs:
            dir_path = project_root / dir_name
            if not dir_path.exists():
                continue
    
            for file_path in dir_path.rglob("*.py"):
                if self.should_exclude_file(file_path):
                    continue
    
                references = self.find_fragile_references(file_path)
                for line_num, line_content in references:
                    # Check for IS_PRIMARY usage without availability checks
                    if "IS_PRIMARY" in line_content:
                        if not any(
                            pattern in line_content
                            for pattern in [
                                "available_columns",
                                "in.*available_columns",
                                r"in.*group_data\.columns",
                                "context=",
                                "get_order_by",
                                "build_sort_expression",
                                "_build_where_clause",
                                "apply_filters_pyarrow",
                                r"\.get\(",
                                "if.*IS_PRIMARY.*in",
                            ]
                        ):
                            violations.append(
                                f"{file_path.relative_to(project_root)}:{line_num} - {line_content}",
                            )
    
        if violations:
>           pytest.fail(
                f"Found {len(violations)} IS_PRIMARY references without availability checks:\n"
                + "\n".join(violations)
                + "\n\nUse conditional filtering with available_columns or context-aware functions.",
            )
E           Failed: Found 7 IS_PRIMARY references without availability checks:
E           src/utils/group_details.py:41 - IS_PRIMARY,
E           src/utils/group_pagination.py:25 - IS_PRIMARY,
E           src/utils/group_pagination.py:583 - IS_PRIMARY,
E           src/utils/group_pagination.py:601 - primary_name_select = f"any_value({ACCOUNT_NAME}) FILTER (WHERE {IS_PRIMARY}) AS {PRIMARY_NAME}"
E           app/components/group_details.py:17 - IS_PRIMARY,
E           app/components/group_details.py:271 - IS_PRIMARY,
E           app/components/group_details.py:314 - IS_PRIMARY: st.column_config.CheckboxColumn(
E           
E           Use conditional filtering with available_columns or context-aware functions.

tests/lints/test_no_schema_fragile_hardcoding.py:250: Failed
_______ TestAliasMatchingParallelism.test_parallel_executor_integration ________

self = <Mock name='mock.should_use_parallel' id='4524013280'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'should_use_parallel' to have been called once. Called 2 times.
E           Calls: [call(5), call(5)].

/Users/joe.j/.pyenv/versions/3.12.2/lib/python3.12/unittest/mock.py:923: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_alias_matching_parallelism.TestAliasMatchingParallelism object at 0x10dba7ce0>

    def test_parallel_executor_integration(self):
        """Test that ParallelExecutor is properly integrated."""
        # Create a mock ParallelExecutor
        mock_executor = Mock(spec=ParallelExecutor)
        mock_executor.should_use_parallel.side_effect = lambda x: True
        mock_executor.workers = 2
        mock_executor.execute_chunked.return_value = [
            [
                {
                    "record_id": 100,
                    "alias_text": "Acme Corp",
                    "match_record_id": 101,
                    "match_group_id": "G1",
                    "score": 95,
                    "suffix_match": True,
                },
            ],
            [
                {
                    "record_id": 101,
                    "alias_text": "Acme Corp",
                    "match_record_id": 100,
                    "match_group_id": "G1",
                    "score": 95,
                    "suffix_match": True,
                },
            ],
        ]
    
        # Call compute_alias_matches with ParallelExecutor
        result_df, stats = compute_alias_matches(
            self.df_norm, self.df_groups, self.settings, parallel_executor=mock_executor,
        )
    
        # Verify ParallelExecutor was used
>       mock_executor.should_use_parallel.assert_called_once()
E       AssertionError: Expected 'should_use_parallel' to have been called once. Called 2 times.
E       Calls: [call(5), call(5)].
E       
E       pytest introspection follows:
E       
E       Args:
E       assert (5,) == ()
E         
E         Left contains one more item: 5
E         Use -v to get more diff

tests/test_alias_matching_parallelism.py:104: AssertionError
_________________ TestCleaning.test_validate_required_columns __________________

self = <tests.test_cleaning.TestCleaning testMethod=test_validate_required_columns>

    def test_validate_required_columns(self) -> None:
        """Test column validation logic."""
        # Test with all required columns
>       self.assertTrue(validate_required_columns(self.sample_data))
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_cleaning.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

df =   Account ID    Account Name         Relationship Created Date
0        001       Acme Corp  Other/Miscellaneous   202...   003  Tech Solutions  Other/Miscellaneous   2021-01-03
3        004  Tech Solutions  Other/Miscellaneous   2021-01-04

    def validate_required_columns(df: pd.DataFrame) -> bool:
        """Validate that required columns are present.
    
        Args:
            df: DataFrame to validate
    
        Returns:
            True if validation passes
    
        Raises:
            ValueError: If required columns are missing
    
        """
        # Use canonical column names since DataFrame has been renamed
        # Only check for columns that are actually mapped and renamed
        required_columns = [ACCOUNT_ID, ACCOUNT_NAME, CREATED_DATE]
    
        # Check for Account Name (required)
        if ACCOUNT_NAME not in df.columns:
>           raise ValueError(f"Missing required name column: {ACCOUNT_NAME}")
E           ValueError: Missing required name column: account_name

src/cleaning.py:314: ValueError
_______________ TestBuildCliCommand.test_build_cli_command_basic _______________

self = <tests.test_cli_builder.TestBuildCliCommand object at 0x10dcf48c0>

    def test_build_cli_command_basic(self) -> None:
        """Test basic command building."""
        cmd = build_cli_command(
            input_file="test.csv",
            config="settings.yaml",
        )
        expected = "python src/cleaning.py --input data/raw/test.csv --outdir data/processed --config config/settings.yaml"
>       assert cmd == expected
E       AssertionError: assert 'python src/c...settings.yaml' == 'python src/c...settings.yaml'
E         
E         Skipping 41 identical leading characters in diff, use -v to show
E         - est.csv --outdir data/processed --config config/settings.yaml
E         ?        ------------------------
E         + est.csv --config config/settings.yaml

tests/test_cli_builder.py:206: AssertionError
_________ TestBuildCliCommand.test_build_cli_command_with_parallelism __________

self = <tests.test_cli_builder.TestBuildCliCommand object at 0x10dcf4a40>

    def test_build_cli_command_with_parallelism(self) -> None:
        """Test command with parallelism flags."""
        cmd = build_cli_command(
            input_file="test.csv",
            config="settings.yaml",
            workers=4,
            parallel_backend="threading",
            chunk_size=1000,
        )
        expected = "python src/cleaning.py --input data/raw/test.csv --outdir data/processed --config config/settings.yaml --workers 4 --parallel-backend threading --chunk-size 1000"
>       assert cmd == expected
E       AssertionError: assert 'python src/c...unk-size 1000' == 'python src/c...unk-size 1000'
E         
E         Skipping 41 identical leading characters in diff, use -v to show
E         - est.csv --outdir data/processed --config config/settings.yaml --workers 4 --parallel-backend threading --chunk-size 1000
E         ?        ------------------------
E         + est.csv --config config/settings.yaml --workers 4 --parallel-backend threading --chunk-size 1000

tests/test_cli_builder.py:218: AssertionError
____________ TestBuildCliCommand.test_build_cli_command_no_parallel ____________

self = <tests.test_cli_builder.TestBuildCliCommand object at 0x10dcf4bc0>

    def test_build_cli_command_no_parallel(self) -> None:
        """Test command with no-parallel flag."""
        cmd = build_cli_command(
            input_file="test.csv",
            config="settings.yaml",
            no_parallel=True,
        )
        expected = "python src/cleaning.py --input data/raw/test.csv --outdir data/processed --config config/settings.yaml --no-parallel"
>       assert cmd == expected
E       AssertionError: assert 'python src/c...--no-parallel' == 'python src/c...--no-parallel'
E         
E         Skipping 41 identical leading characters in diff, use -v to show
E         - est.csv --outdir data/processed --config config/settings.yaml --no-parallel
E         ?        ------------------------
E         + est.csv --config config/settings.yaml --no-parallel

tests/test_cli_builder.py:228: AssertionError
_________ TestBuildCliCommand.test_build_cli_command_with_run_control __________

self = <tests.test_cli_builder.TestBuildCliCommand object at 0x10dcf4d40>

    def test_build_cli_command_with_run_control(self) -> None:
        """Test command with run control flags."""
        cmd = build_cli_command(
            input_file="test.csv",
            config="settings.yaml",
            no_resume=True,
            run_id="custom_run_123",
            keep_runs=5,
        )
        expected = "python src/cleaning.py --input data/raw/test.csv --outdir data/processed --config config/settings.yaml --no-resume --run-id custom_run_123 --keep-runs 5"
>       assert cmd == expected
E       AssertionError: assert 'python src/c...--keep-runs 5' == 'python src/c...--keep-runs 5'
E         
E         Skipping 41 identical leading characters in diff, use -v to show
E         - est.csv --outdir data/processed --config config/settings.yaml --no-resume --run-id custom_run_123 --keep-runs 5
E         ?        ------------------------
E         + est.csv --config config/settings.yaml --no-resume --run-id custom_run_123 --keep-runs 5

tests/test_cli_builder.py:240: AssertionError
__________ TestBuildCliCommand.test_build_cli_command_with_extra_args __________

self = <tests.test_cli_builder.TestBuildCliCommand object at 0x10dcf4ec0>

    def test_build_cli_command_with_extra_args(self) -> None:
        """Test command with extra arguments."""
        cmd = build_cli_command(
            input_file="test.csv",
            config="settings.yaml",
            extra_args="--verbose --debug",
        )
        expected = "python src/cleaning.py --input data/raw/test.csv --outdir data/processed --config config/settings.yaml --verbose --debug"
>       assert cmd == expected
E       AssertionError: assert 'python src/c...rbose --debug' == 'python src/c...rbose --debug'
E         
E         Skipping 41 identical leading characters in diff, use -v to show
E         - est.csv --outdir data/processed --config config/settings.yaml --verbose --debug
E         ?        ------------------------
E         + est.csv --config config/settings.yaml --verbose --debug

tests/test_cli_builder.py:250: AssertionError
___________ TestBuildCliCommand.test_build_cli_command_custom_outdir ___________

self = <tests.test_cli_builder.TestBuildCliCommand object at 0x10dcf5040>

    def test_build_cli_command_custom_outdir(self) -> None:
        """Test command with custom output directory."""
        cmd = build_cli_command(
            input_file="test.csv",
            config="settings.yaml",
            outdir="custom/output",
        )
        expected = "python src/cleaning.py --input data/raw/test.csv --outdir custom/output --config config/settings.yaml"
>       assert cmd == expected
E       AssertionError: assert 'python src/c...custom/output' == 'python src/c...settings.yaml'
E         
E         Skipping 41 identical leading characters in diff, use -v to show
E         - est.csv --outdir custom/output --config config/settings.yaml
E         + est.csv --config config/settings.yaml --outdir custom/output

tests/test_cli_builder.py:260: AssertionError
_____ TestGroupDetailsDuckDB.test_get_group_details_duckdb_file_not_found ______

self = <tests.test_details_fast_path.TestGroupDetailsDuckDB object at 0x10dcf7110>
mock_exists = <MagicMock name='exists' id='4532721840'>
mock_get_paths = <MagicMock name='get_artifact_paths' id='4532912000'>

    @patch("src.utils.artifact_management.get_artifact_paths")
    @patch("os.path.exists")
    def test_get_group_details_duckdb_file_not_found(
        self, mock_exists: MagicMock, mock_get_paths: MagicMock,
    ) -> None:
        """Test DuckDB details loading when file not found."""
        # Mock artifact paths
        mock_get_paths.return_value = {
            "group_details_parquet": "/test/path/group_details.parquet",
        }
        mock_exists.return_value = False
    
        # Test the function should raise FileNotFoundError
        with pytest.raises(FileNotFoundError):
>           get_group_details_duckdb(
                "/test/path/group_details.parquet",
                "group1",
                "account_id",
                1,
                10,
                {},
                {},
            )

tests/test_details_fast_path.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

parquet_path = '/test/path/group_details.parquet', group_id = 'group1'
order_by = 'account_id', page = 1, page_size = 10, filters = {}, settings = {}

    def _get_group_details_duckdb(
        parquet_path: str,
        group_id: str,
        order_by: str,
        page: int,
        page_size: int,
        filters: Dict[str, Any],
        settings: Dict[str, Any],
    ) -> Tuple[List[Dict[str, Any]], int]:
        """DuckDB backend for group details (fast filtering + pagination)."""
        if DUCKDB is None:
            raise ImportError("DuckDB not available for group details")
    
        duckdb_threads = settings.get("ui", {}).get("duckdb_threads", 4)
        timeout_seconds = settings.get("ui", {}).get("timeout_seconds", 30)
    
        start = time.time()
    
        def check_timeout() -> None:
            if time.time() - start > timeout_seconds:
                raise DetailsFetchTimeout(f"Exceeded {timeout_seconds}s")
    
        # Get available columns dynamically
        available_columns = _get_available_columns(parquet_path)
        dynamic_select = _build_dynamic_select(available_columns)
    
        where_clause, params = _build_where_clause(filters, available_columns)
        # Clamp pagination inputs to avoid negative offsets and cap for performance
        page = max(1, int(page))
        requested_size = int(page_size)
        max_page_size = settings.get("ui", {}).get("max_page_size", 250)
        page_size = max(1, min(requested_size, max_page_size))
        if page_size != requested_size:  # Log when clamping occurs
            logger.info(
                "Page size clamped from %s to %s (max_page_size limit)",
                requested_size,
                max_page_size,
            )
            record_page_size_clamped()
        offset = (page - 1) * page_size
    
        # Build SQL using dynamic column selection
        sql = (
            dynamic_select + "WHERE " + GROUP_ID + " = ? AND " + where_clause + " "
            "ORDER BY "
            + order_by
            + " NULLS LAST, "
            + ACCOUNT_NAME
            + " ASC "  # order_by from get_order_by whitelist, stable tie-breaker, NULLs last
            "LIMIT ? OFFSET ?"
        )
        params_page = [parquet_path, group_id, *params, page_size, offset]
    
        count_sql = (
            "SELECT COUNT(*) FROM read_parquet(?) "
            "WHERE " + GROUP_ID + " = ? AND " + where_clause
        )
        params_count = [parquet_path, group_id, *params]
    
        conn = None
        try:
            conn = DUCKDB.connect(":memory:")
            duckdb_threads = int(duckdb_threads or 4)  # Ensure numeric
            duckdb_threads = min(duckdb_threads, 32)  # Double-enforce caps at call site
            conn.execute("PRAGMA threads=" + str(duckdb_threads))
            check_timeout()
    
>           res = conn.execute(sql, params_page)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           duckdb.duckdb.IOException: IO Error: No files found that match the pattern "/test/path/group_details.parquet"

src/utils/group_details.py:373: IOException
------------------------------ Captured log call -------------------------------
WARNING  src.utils.group_details:group_details.py:96 Failed to read schema from /test/path/group_details.parquet: [Errno 2] Failed to open local file '/test/path/group_details.parquet'. Detail: [errno 2] No such file or directory
______ TestGroupsRouting.test_groups_use_duckdb_when_stats_parquet_exists ______

self = <tests.test_details_fast_path.TestGroupsRouting object at 0x10dcf7440>
mock_exists = <MagicMock name='exists' id='4532293696'>
mock_get_paths = <MagicMock name='get_artifact_paths' id='4532298496'>

    @patch("src.utils.artifact_management.get_artifact_paths")
    @patch("os.path.exists")
    @patch("src.utils.opt_deps.DUCKDB_AVAILABLE", True)
    def test_groups_use_duckdb_when_stats_parquet_exists(
        self, mock_exists: MagicMock, mock_get_paths: MagicMock,
    ) -> None:
        """Test that groups page uses DuckDB when group_stats.parquet exists."""
        from src.utils.group_pagination import get_groups_page
    
        # Mock artifact paths with group_stats.parquet
        mock_get_paths.return_value = {
            "group_stats_parquet": "/test/path/group_stats.parquet",
        }
        mock_exists.return_value = True
    
        # Mock the DuckDB function to return test data
>       with patch(
            "src.utils.ui_helpers.get_groups_page_from_stats_duckdb",
        ) as mock_duckdb:

tests/test_details_fast_path.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Users/joe.j/.pyenv/versions/3.12.2/lib/python3.12/unittest/mock.py:1439: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.utils.ui_helpers'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.utils' has no attribute 'ui_helpers'

/Users/joe.j/.pyenv/versions/3.12.2/lib/python3.12/pkgutil.py:528: AttributeError
__ TestGroupsRouting.test_groups_fallback_to_pyarrow_when_duckdb_unavailable ___

self = <tests.test_details_fast_path.TestGroupsRouting object at 0x10dcf7590>
mock_exists = <MagicMock name='exists' id='4531859968'>
mock_get_paths = <MagicMock name='get_artifact_paths' id='4526271248'>

    @patch("src.utils.artifact_management.get_artifact_paths")
    @patch("os.path.exists")
    @patch("src.utils.opt_deps.DUCKDB_AVAILABLE", False)
    def test_groups_fallback_to_pyarrow_when_duckdb_unavailable(
        self, mock_exists: MagicMock, mock_get_paths: MagicMock,
    ) -> None:
        """Test that groups page falls back to PyArrow when DuckDB unavailable."""
        from src.utils.group_pagination import get_groups_page
    
        # Mock artifact paths with group_stats.parquet
        mock_get_paths.return_value = {
            "group_stats_parquet": "/test/path/group_stats.parquet",
        }
        mock_exists.return_value = True
    
        # Mock the PyArrow function to return test data
>       with patch("src.utils.ui_helpers.get_groups_page_pyarrow") as mock_pyarrow:

tests/test_details_fast_path.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Users/joe.j/.pyenv/versions/3.12.2/lib/python3.12/unittest/mock.py:1439: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.utils.ui_helpers'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.utils' has no attribute 'ui_helpers'

/Users/joe.j/.pyenv/versions/3.12.2/lib/python3.12/pkgutil.py:528: AttributeError
_______________ TestDisposition.test_manual_override_application _______________

self = <tests.test_disposition.TestDisposition testMethod=test_manual_override_application>

    def test_manual_override_application(self) -> None:
        """Test that manual overrides are applied correctly."""
        import json
        from pathlib import Path
    
        # Create test data
        test_data = pd.DataFrame(
            {
                "group_id": [1, 1],
                "Account Name": ["Acme Corp Inc", "Acme Corp Inc"],
                "is_primary": [True, False],
                "weakest_edge_to_primary": [100, 95],
                "suffix_class": ["INC", "INC"],
                "has_multiple_names": [False, False],
            },
        )
    
        # Create manual override file
        manual_dir = Path("data/manual")
        manual_dir.mkdir(parents=True, exist_ok=True)
    
        override_data = [
            {
                "record_id": "0",  # First record
                "account_id": "001Hs000054S8kI",
                "account_name": "Acme Corp Inc",
                "name_core": "acme corp",
                "override": "Delete",
                "reason": "Test override",
                "ts": "2024-01-01T00:00:00",
            },
        ]
    
        with open(manual_dir / "manual_dispositions.json", "w") as f:
            json.dump(override_data, f)
    
        try:
            # Apply dispositions
            result = apply_dispositions(test_data, self.settings)
    
            # Check that manual override was applied
            self.assertEqual(result.iloc[0]["disposition"], "Delete")
>           self.assertEqual(
                result.iloc[0]["disposition_reason"], "manual_override:Delete",
            )
E           AssertionError: 'primary_record' != 'manual_override:Delete'
E           - primary_record
E           + manual_override:Delete

tests/test_disposition.py:299: AssertionError
_______________ TestDisposition.test_multiple_names_verification _______________

self = <tests.test_disposition.TestDisposition testMethod=test_multiple_names_verification>

    def test_multiple_names_verification(self) -> None:
        """Test that records with multiple names are marked as Verify."""
        # Create test data with multiple names
        df_groups = self.df_norm.copy()
        df_groups["group_id"] = [0, 1, 2, 3, 4, 5, 6, 7]
        df_groups["is_primary"] = [True] * 8
        df_groups["weakest_edge_to_primary"] = [0.0] * 8
    
        # Add multiple names flag
        df_groups.loc[0, "has_multiple_names"] = True
        df_groups.loc[1, "has_multiple_names"] = True
    
        df_dispositions = apply_dispositions(df_groups, self.settings)
    
        # Check that multiple names are marked as Verify
        self.assertEqual(df_dispositions.iloc[0]["disposition"], "Verify")
        self.assertEqual(df_dispositions.iloc[1]["disposition"], "Verify")
>       self.assertEqual(
            df_dispositions.iloc[0]["disposition_reason"],
            "multi_name_string_requires_split",
        )
E       AssertionError: 'clean_singleton' != 'multi_name_string_requires_split'
E       - clean_singleton
E       + multi_name_string_requires_split

tests/test_disposition.py:252: AssertionError
___________________________ test_duckdb_memoization ____________________________

    def test_duckdb_memoization() -> None:
        """Test that memoization works correctly."""
        df = create_test_group_data()
    
        with tempfile.TemporaryDirectory() as _temp_dir:
            settings = {
                "engine": {"duckdb": {"threads": 2}},
                "io": {"parquet": {"compression": "zstd"}},
>               "group_stats": {"memoization": {"enable": True}, "cache_dir": temp_dir},
                                                                              ^^^^^^^^
            }
E           NameError: name 'temp_dir' is not defined

tests/test_duckdb_group_stats_phase1354.py:154: NameError
__________________________ test_duckdb_parquet_write ___________________________

    def test_duckdb_parquet_write() -> None:
        """Test that DuckDB can write optimized Parquet files."""
        df = create_test_group_data()
    
        with tempfile.TemporaryDirectory() as _temp_dir:
            settings = {
                "engine": {"duckdb": {"threads": 2}},
                "io": {"parquet": {"compression": "zstd"}},
>               "group_stats": {"memoization": {"enable": True}, "cache_dir": temp_dir},
                                                                              ^^^^^^^^
            }
E           NameError: name 'temp_dir' is not defined

tests/test_duckdb_group_stats_phase1354.py:200: NameError
__________________________ test_parquet_size_reporter __________________________

    def test_parquet_size_reporter() -> None:
        """Test that parquet size reporter works correctly."""
        df = create_test_group_data()
    
        with tempfile.TemporaryDirectory() as _temp_dir:
            # Create test parquet file
>           test_path = f"{temp_dir}/test.parquet"
                           ^^^^^^^^
E           NameError: name 'temp_dir' is not defined

tests/test_duckdb_group_stats_phase1354.py:282: NameError
_________________________ test_performance_improvement _________________________

    def test_performance_improvement() -> None:
        """Test that DuckDB is faster than pandas for group stats."""
        # Create larger test dataset
        n_records = 1000
        n_groups = 100
    
        # Ensure each group has exactly one primary record
        group_primary_map = {}
        is_primary_list = []
    
        for i in range(n_records):
            group_id = f"G{i % n_groups}"
            if group_id not in group_primary_map:
                group_primary_map[group_id] = i
                is_primary_list.append(True)
            else:
                is_primary_list.append(False)
    
        df_large = pd.DataFrame(
            {
                "group_id": [f"G{i % n_groups}" for i in range(n_records)],
                "account_id": [f"A{i}" for i in range(n_records)],
                "account_name": [f"Company {i % n_groups}" for i in range(n_records)],
                "is_primary": is_primary_list,
                "weakest_edge_to_primary": [
                    np.random.uniform(80, 100) for _ in range(n_records)
                ],
                "disposition": [
                    "Keep" if is_primary else "Update" for is_primary in is_primary_list
                ],
            },
        )
    
        with tempfile.TemporaryDirectory() as _temp_dir:
            settings = {
                "engine": {"duckdb": {"threads": 2}},
                "io": {"parquet": {"compression": "zstd"}},
>               "group_stats": {"memoization": {"enable": True}, "cache_dir": temp_dir},
                                                                              ^^^^^^^^
            }
E           NameError: name 'temp_dir' is not defined

tests/test_duckdb_group_stats_phase1354.py:344: NameError
_________________________ test_no_f_string_sql_queries _________________________

    def test_no_f_string_sql_queries():
        """Verify no f-string SQL queries exist in group-related modules.
    
        This test ensures all DuckDB queries use parameterized placeholders
        instead of string interpolation to prevent SQL injection.
        """
        # Files to check for SQL queries
        sql_files = [
            "src/utils/group_pagination.py",
            "src/utils/group_details.py",
            "src/utils/group_stats.py",
            "src/utils/filtering.py",
        ]
    
        violations = []
    
        for file_path in sql_files:
            if Path(file_path).exists():
                f_strings = find_string_interpolations(file_path)
                if f_strings:
                    violations.append(
                        f"{file_path}: {len(f_strings)} f-string SQL queries found",
                    )
    
        if violations:
>           pytest.fail(
                "Found f-string SQL queries. All DuckDB queries must use parameterized placeholders:\n"
                + "\n".join(violations)
                + "\n\nExample of correct usage:\n"
                + "query = 'SELECT * FROM groups WHERE run_id = ?'\n"
                + "result = conn.execute(query, [run_id]).fetchdf()",
            )
E           Failed: Found f-string SQL queries. All DuckDB queries must use parameterized placeholders:
E           src/utils/group_pagination.py: 1 f-string SQL queries found
E           src/utils/group_details.py: 2 f-string SQL queries found
E           
E           Example of correct usage:
E           query = 'SELECT * FROM groups WHERE run_id = ?'
E           result = conn.execute(query, [run_id]).fetchdf()

tests/test_duckdb_query_params.py:170: Failed
________ TestGroupStatsComputation.test_compute_group_stats_no_primary _________

self = <tests.test_groups_pagination.TestGroupStatsComputation object at 0x10ddb21b0>

    def test_compute_group_stats_no_primary(self) -> None:
        """Test handling when no primary record exists."""
        data: Dict[str, List[Any]] = {
            "group_id": ["group1", "group1"],
            "account_name": ["Company A", "Company B"],
            "is_primary": [False, False],
            "weakest_edge_to_primary": [95.0, 85.0],
        }
    
        table = pa.Table.from_pydict(data)
        df = table.to_pandas()
        stats_table = compute_group_stats(df)
        stats_df = stats_table
    
        group1_stats = stats_df[stats_df["group_id"] == "group1"].iloc[0]
>       assert group1_stats["primary_name"] == "Company A"  # First record
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert None == 'Company A'

tests/test_groups_pagination.py:193: AssertionError
________ TestFilterApplication.test_apply_filters_pyarrow_edge_strength ________

self = <tests.test_groups_pagination.TestFilterApplication object at 0x10dd8b890>

    def test_apply_filters_pyarrow_edge_strength(self) -> None:
        """Test edge strength filtering."""
        data: Dict[str, List[Any]] = {
            "group_id": ["group1", "group2", "group3"],
            "weakest_edge_to_primary": [95.0, 85.0, 75.0],
        }
    
        table = pa.Table.from_pydict(data)
        filters = {"min_edge_strength": 80.0}
    
>       filtered_table = apply_filters_pyarrow(table, filters)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_groups_pagination.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/filtering.py:155: in apply_filters_pyarrow
    es_mask = pc.greater_equal(
/Users/joe.j/.pyenv/versions/3.12.2/lib/python3.12/site-packages/pyarrow/compute.py:252: in wrapper
    return func.call(args, None, memory_pool)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pyarrow/_compute.pyx:386: in pyarrow._compute.Function.call
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   TypeError: Got unexpected argument type <class 'pyarrow._compute.Expression'> for compute function

pyarrow/_compute.pyx:519: TypeError
___________ TestPaginationLimits.test_pagination_limits_page_bounds ____________

self = <tests.test_groups_pagination.TestPaginationLimits object at 0x10ddb1940>

    def test_pagination_limits_page_bounds(self) -> None:
        """Test pagination with page bounds."""
        # Create test data with known number of groups
        data: Dict[str, List[Any]] = {
            "group_id": [f"group{i}" for i in range(10)],
            "account_name": [f"Company {i}" for i in range(10)],
            "is_primary": [True] + [False] * 9,
            "weakest_edge_to_primary": [95.0] * 10,
        }
    
        with tempfile.TemporaryDirectory() as temp_dir:
            table = pa.Table.from_pydict(data)
            parquet_path = os.path.join(temp_dir, "review_ready.parquet")
            pa.parquet.write_table(table, parquet_path)
    
            # Mock artifact paths
            def mock_get_artifact_paths(run_id: str) -> Dict[str, str]:
                return {"review_ready_parquet": parquet_path}
    
            import src.utils.artifact_management
    
            original_get_artifact_paths = (
                src.utils.artifact_management.get_artifact_paths
            )
            src.utils.artifact_management.get_artifact_paths = mock_get_artifact_paths
    
            try:
                # Test first page
                page_groups, total_count = get_groups_page_pyarrow(
                    "test_run", "Group Size (Desc)", 1, 5, {},
                )
    
>               assert len(page_groups) == 5
E               assert 0 == 5
E                +  where 0 = len([])

tests/test_groups_pagination.py:321: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  src.utils.group_pagination:group_pagination.py:307 Parquet file not found: data/processed/test_run/review_ready.parquet
_______ TestSortingStability.test_sorting_stability_group_id_tiebreaker ________

self = <tests.test_groups_pagination.TestSortingStability object at 0x10ddb1220>

    def test_sorting_stability_group_id_tiebreaker(self) -> None:
        """Test that group_id tiebreaker ensures stable sorting."""
        # Create test data with same values but different group_ids
        data: Dict[str, List[Any]] = {
            "group_id": [
                "group_b",
                "group_b",
                "group_a",
                "group_a",
                "group_c",
                "group_c",
            ],
            "account_name": [
                "Company B1",
                "Company B2",
                "Company A1",
                "Company A2",
                "Company C1",
                "Company C2",
            ],
            "is_primary": [True, False, True, False, True, False],
            "weakest_edge_to_primary": [90.0, 90.0, 90.0, 90.0, 90.0, 90.0],
        }
    
        with tempfile.TemporaryDirectory() as temp_dir:
            table = pa.Table.from_pydict(data)
            parquet_path = os.path.join(temp_dir, "review_ready.parquet")
            pa.parquet.write_table(table, parquet_path)
    
            # Mock artifact paths
            def mock_get_artifact_paths(run_id: str) -> Dict[str, str]:
                return {"review_ready_parquet": parquet_path}
    
            import src.utils.artifact_management
    
            original_get_artifact_paths = (
                src.utils.artifact_management.get_artifact_paths
            )
            src.utils.artifact_management.get_artifact_paths = mock_get_artifact_paths
    
            try:
                # Test ascending sort - should be stable by group_id
                page_groups, _ = get_groups_page_pyarrow(
                    "test_run", "Group Size (Asc)", 1, 10, {},
                )
    
                # Should be sorted by group_id (ascending) as tiebreaker
                group_ids = [group["group_id"] for group in page_groups]
>               assert group_ids == ["group_a", "group_b", "group_c"]
E               AssertionError: assert [] == ['group_a', '...b', 'group_c']
E                 
E                 Right contains 3 more items, first extra item: 'group_a'
E                 Use -v to get more diff

tests/test_groups_pagination.py:396: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  src.utils.group_pagination:group_pagination.py:307 Parquet file not found: data/processed/test_run/review_ready.parquet
____________________________ test_import_src_utils _____________________________

    def test_import_src_utils() -> None:
        """Test importing src.utils modules."""
        utils = [
            "src.utils.cache_utils",
            "src.utils.logging_utils",
            "src.utils.path_utils",
            # "src.utils.ui_helpers",  # Deprecated - moved to deprecated/ folder
            "src.utils.state_utils",  # Phase 1.18.1 new
            "src.utils.sort_utils",  # Phase 1.18.1 new
            "src.utils.cli_builder",
            "src.utils.id_utils",
            "src.utils.io_utils",
            "src.utils.mini_dag",
            "src.utils.parallel_utils",
            "src.utils.perf_utils",
            "src.utils.progress",
            "src.utils.resource_monitor",
            "src.utils.dtypes",
            "src.utils.hash_utils",
            "src.utils.validation_utils",
        ]
    
        for util in utils:
            try:
>               importlib.import_module(util)

tests/test_import_audit.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Users/joe.j/.pyenv/versions/3.12.2/lib/python3.12/importlib/__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1387: in _gcd_import
    ???
<frozen importlib._bootstrap>:1360: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.utils.validation_utils'
import_ = <function _gcd_import at 0x102b400e0>

>   ???
E   ModuleNotFoundError: No module named 'src.utils.validation_utils'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

    def test_import_src_utils() -> None:
        """Test importing src.utils modules."""
        utils = [
            "src.utils.cache_utils",
            "src.utils.logging_utils",
            "src.utils.path_utils",
            # "src.utils.ui_helpers",  # Deprecated - moved to deprecated/ folder
            "src.utils.state_utils",  # Phase 1.18.1 new
            "src.utils.sort_utils",  # Phase 1.18.1 new
            "src.utils.cli_builder",
            "src.utils.id_utils",
            "src.utils.io_utils",
            "src.utils.mini_dag",
            "src.utils.parallel_utils",
            "src.utils.perf_utils",
            "src.utils.progress",
            "src.utils.resource_monitor",
            "src.utils.dtypes",
            "src.utils.hash_utils",
            "src.utils.validation_utils",
        ]
    
        for util in utils:
            try:
                importlib.import_module(util)
            except ImportError as e:
>               pytest.fail(f"Failed to import {util}: {e}")
E               Failed: Failed to import src.utils.validation_utils: No module named 'src.utils.validation_utils'

tests/test_import_audit.py:37: Failed
____________________________ test_absolute_imports _____________________________

    def test_absolute_imports() -> None:
        """Test that all modules can be imported using absolute imports."""
        modules_to_test = [
            # Core modules
            "src.utils.cache_utils",
            "src.utils.dtypes",
            "src.utils.hash_utils",
            "src.utils.io_utils",
            "src.utils.logging_utils",
            "src.utils.parallel_utils",
            "src.utils.path_utils",
            "src.utils.perf_utils",
            "src.utils.resource_monitor",
            "src.utils.sort_utils",
            "src.utils.state_utils",
            "src.utils.validation_utils",
            "src.utils.fragment_utils",  # Phase 1.18.3 addition
            # "src.utils.ui_helpers",  # Deprecated - moved to deprecated/ folder
            "src.alias_matching",
            "src.cleaning",
            "src.disposition",
            "src.grouping",
            "src.manual_io",
            "src.normalize",
            "src.performance",
            "src.salesforce",
            "src.similarity",
            "src.survivorship",
            # App modules
            "app.components.controls",
            "app.components.export",
            "app.components.group_details",
            "app.components.group_list",
            "app.components.maintenance",
            "app.main",
        ]
    
        for module_name in modules_to_test:
            try:
>               module = __import__(module_name, fromlist=[""])
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               ModuleNotFoundError: No module named 'src.utils.validation_utils'

tests/test_imports.py:49: ModuleNotFoundError

During handling of the above exception, another exception occurred:

    def test_absolute_imports() -> None:
        """Test that all modules can be imported using absolute imports."""
        modules_to_test = [
            # Core modules
            "src.utils.cache_utils",
            "src.utils.dtypes",
            "src.utils.hash_utils",
            "src.utils.io_utils",
            "src.utils.logging_utils",
            "src.utils.parallel_utils",
            "src.utils.path_utils",
            "src.utils.perf_utils",
            "src.utils.resource_monitor",
            "src.utils.sort_utils",
            "src.utils.state_utils",
            "src.utils.validation_utils",
            "src.utils.fragment_utils",  # Phase 1.18.3 addition
            # "src.utils.ui_helpers",  # Deprecated - moved to deprecated/ folder
            "src.alias_matching",
            "src.cleaning",
            "src.disposition",
            "src.grouping",
            "src.manual_io",
            "src.normalize",
            "src.performance",
            "src.salesforce",
            "src.similarity",
            "src.survivorship",
            # App modules
            "app.components.controls",
            "app.components.export",
            "app.components.group_details",
            "app.components.group_list",
            "app.components.maintenance",
            "app.main",
        ]
    
        for module_name in modules_to_test:
            try:
                module = __import__(module_name, fromlist=[""])
                assert module is not None
            except ImportError as e:
>               pytest.fail(f"Failed to import {module_name}: {e}")
E               Failed: Failed to import src.utils.validation_utils: No module named 'src.utils.validation_utils'

tests/test_imports.py:52: Failed
______________________________ test_utils_imports ______________________________

    def test_utils_imports() -> None:
        """Test that all utility modules can be imported."""
        utils_modules = [
            "src.utils.cache_utils",
            "src.utils.dtypes",
            "src.utils.hash_utils",
            "src.utils.io_utils",
            "src.utils.logging_utils",
            "src.utils.parallel_utils",
            "src.utils.path_utils",
            "src.utils.perf_utils",
            "src.utils.resource_monitor",
            "src.utils.sort_utils",
            "src.utils.state_utils",
            "src.utils.validation_utils",
            "src.utils.fragment_utils",  # Phase 1.18.3 addition
            # "src.utils.ui_helpers",  # Deprecated - moved to deprecated/ folder
        ]
    
        for module_name in utils_modules:
            try:
>               module = __import__(module_name, fromlist=[""])
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               ModuleNotFoundError: No module named 'src.utils.validation_utils'

tests/test_imports.py:94: ModuleNotFoundError

During handling of the above exception, another exception occurred:

    def test_utils_imports() -> None:
        """Test that all utility modules can be imported."""
        utils_modules = [
            "src.utils.cache_utils",
            "src.utils.dtypes",
            "src.utils.hash_utils",
            "src.utils.io_utils",
            "src.utils.logging_utils",
            "src.utils.parallel_utils",
            "src.utils.path_utils",
            "src.utils.perf_utils",
            "src.utils.resource_monitor",
            "src.utils.sort_utils",
            "src.utils.state_utils",
            "src.utils.validation_utils",
            "src.utils.fragment_utils",  # Phase 1.18.3 addition
            # "src.utils.ui_helpers",  # Deprecated - moved to deprecated/ folder
        ]
    
        for module_name in utils_modules:
            try:
                module = __import__(module_name, fromlist=[""])
                assert module is not None
            except ImportError as e:
>               pytest.fail(f"Failed to import utility {module_name}: {e}")
E               Failed: Failed to import utility src.utils.validation_utils: No module named 'src.utils.validation_utils'

tests/test_imports.py:97: Failed
________ TestInterruptResumeIntegration.test_interrupt_resume_workflow _________

self = <tests.test_interrupt_resume.TestInterruptResumeIntegration object at 0x10dde1be0>

        def test_interrupt_resume_workflow(self) -> None:
            """Test the complete interrupt and resume workflow."""
            # Create test CSV
            csv_path = self.create_test_csv("test_interrupt.csv", 5)
    
            try:
                # Create temporary directories
                temp_dir = tempfile.mkdtemp()
                interim_dir = os.path.join(temp_dir, "interim")
                processed_dir = os.path.join(temp_dir, "processed")
                os.makedirs(interim_dir)
                os.makedirs(processed_dir)
    
                # Create a minimal config
                config_path = os.path.join(temp_dir, "test_config.yaml")
                with open(config_path, "w") as f:
                    f.write(
                        """
    similarity:
      high: 92
      medium: 84
      penalty:
        suffix_mismatch: 25
        num_style_mismatch: 5
    parallelism:
      workers: 1
      backend: "threading"
      chunk_size: 1000
      small_input_threshold: 1000
    """,
                    )
    
                # Test that we can run a small pipeline
                cmd = [
                    sys.executable,
                    "src/cleaning.py",
                    "--input",
                    csv_path,
                    "--outdir",
                    processed_dir,
                    "--config",
                    config_path,
                    "--workers",
                    "1",
                    "--parallel-backend",
                    "threading",
                    "--no-resume",
                ]
    
                # Run the pipeline (should complete quickly with small data)
                result = subprocess.run(cmd, check=False, capture_output=True, text=True, timeout=30)
    
                # Should complete successfully
>               assert result.returncode == 0, f"Pipeline failed: {result.stderr}"
E               AssertionError: Pipeline failed: Traceback (most recent call last):
E                   File "/Users/joe.j/Documents/dev/salesforce/apps/company_junction/src/cleaning.py", line 24, in <module>
E                     from src.alias_matching import (
E                 ModuleNotFoundError: No module named 'src'
E                 
E               assert 1 == 0
E                +  where 1 = CompletedProcess(args=['/Users/joe.j/.pyenv/versions/3.12.2/bin/python3.12', 'src/cleaning.py', '--input', '/var/folde...aning.py", line 24, in <module>\n    from src.alias_matching import (\nModuleNotFoundError: No module named \'src\'\n').returncode

tests/test_interrupt_resume.py:163: AssertionError
____________________________ test_validate_csv_file ____________________________

    def test_validate_csv_file():
        """Test CSV file validation."""
        # Test with valid file
>       assert validate_csv_file("test.csv") is True
E       AssertionError: assert False is True
E        +  where False = validate_csv_file('test.csv')

tests/test_io_utils.py:348: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    src.utils.io_utils:io_utils.py:434 CSV validation failed for test.csv: [Errno 2] No such file or directory: 'test.csv'
____________________________ test_track_memory_peak ____________________________

caplog = <_pytest.logging.LogCaptureFixture object at 0x10e7666f0>

    def test_track_memory_peak(caplog: pytest.LogCaptureFixture) -> None:
        """Test memory peak tracking context manager."""
        # Set up logging to capture messages
        caplog.set_level(logging.INFO)
        logger = logging.getLogger("test")
    
        with track_memory_peak("test_stage", logger):
            # Simulate some memory usage
            pass
    
        # Should log memory peak
>       assert "Memory peak at 'test_stage'" in caplog.text
E       assert "Memory peak at 'test_stage'" in ''
E        +  where '' = <_pytest.logging.LogCaptureFixture object at 0x10e7666f0>.text

tests/test_perf_utils.py:28: AssertionError
_______________________________ test_time_stage ________________________________

caplog = <_pytest.logging.LogCaptureFixture object at 0x10dcf7fb0>

    def test_time_stage(caplog: pytest.LogCaptureFixture) -> None:
        """Test stage timing context manager."""
        # Set up logging to capture messages
        caplog.set_level(logging.INFO)
        logger = logging.getLogger("test")
    
        with time_stage("test_stage", logger):
            # Simulate some work
            time.sleep(0.01)
    
        # Should log timing
>       assert "Stage 'test_stage' completed in" in caplog.text
E       assert "Stage 'test_stage' completed in" in 'INFO     test:perf_utils.py:242 [stage:start] test_stage\nINFO     test:perf_utils.py:247 [stage:end] test_stage (0.01s)\n'
E        +  where 'INFO     test:perf_utils.py:242 [stage:start] test_stage\nINFO     test:perf_utils.py:247 [stage:end] test_stage (0.01s)\n' = <_pytest.logging.LogCaptureFixture object at 0x10dcf7fb0>.text

tests/test_perf_utils.py:42: AssertionError
------------------------------ Captured log call -------------------------------
INFO     test:perf_utils.py:242 [stage:start] test_stage
INFO     test:perf_utils.py:247 [stage:end] test_stage (0.01s)
___________ TestReadOnlySafety.test_no_destructive_functions_in_code ___________

self = <tests.test_readonly_safety.TestReadOnlySafety object at 0x10de6f3e0>

    def test_no_destructive_functions_in_code(self) -> None:
        """Test that no destructive functions are called in the codebase."""
        destructive_functions = find_destructive_functions()
    
        # Filter out legitimate uses (like in tests or cleanup tools)
        legitimate_uses = set()
        for func in destructive_functions:
            file_path = func.split(":")[0]
            if any(legit in file_path for legit in ["test_", "cleanup_", "tools/"]):
                legitimate_uses.add(func)
    
        # Remove legitimate uses from the set
        problematic_functions = destructive_functions - legitimate_uses
    
>       assert len(problematic_functions) == 0, (
            f"Found potentially destructive functions in production code:\n"
            f"{chr(10).join(sorted(problematic_functions))}\n"
            f"All destructive operations must be gated behind Phase-1 fuses."
        )
E       AssertionError: Found potentially destructive functions in production code:
E         app/components/maintenance.py:212:preview_delete_runs
E         app/components/maintenance.py:232:delete_runs
E         scripts/run_modes_benchmark.py:345:shutil.rmtree
E         All destructive operations must be gated behind Phase-1 fuses.
E       assert 3 == 0
E        +  where 3 = len({'app/components/maintenance.py:212:preview_delete_runs', 'app/components/maintenance.py:232:delete_runs', 'scripts/run_modes_benchmark.py:345:shutil.rmtree'})

tests/test_readonly_safety.py:231: AssertionError
__________ TestReadOnlySafety.test_maintenance_ui_shows_readonly_copy __________

self = <tests.test_readonly_safety.TestReadOnlySafety object at 0x10de6f6e0>

    def test_maintenance_ui_shows_readonly_copy(self) -> None:
        """Test that maintenance UI shows the correct read-only message."""
>       assert (
            check_maintenance_ui_copy()
        ), "Maintenance UI must show: 'Run deletion functionality will be implemented in a future phase.'"
E       AssertionError: Maintenance UI must show: 'Run deletion functionality will be implemented in a future phase.'
E       assert False
E        +  where False = check_maintenance_ui_copy()

tests/test_readonly_safety.py:259: AssertionError
___________ TestReadOnlySafety.test_maintenance_rendered_in_sidebar ____________

self = <tests.test_readonly_safety.TestReadOnlySafety object at 0x10de6f860>

    def test_maintenance_rendered_in_sidebar(self) -> None:
        """Test that maintenance is rendered in sidebar context."""
>       assert (
            check_sidebar_placement()
        ), "Maintenance component must be rendered in sidebar using st.sidebar.subheader"
E       AssertionError: Maintenance component must be rendered in sidebar using st.sidebar.subheader
E       assert False
E        +  where False = check_sidebar_placement()

tests/test_readonly_safety.py:265: AssertionError
______________________ test_header_list_raises_typeerror _______________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x10e2a7920>

    def test_header_list_raises_typeerror(monkeypatch: pytest.MonkeyPatch) -> None:
        def fake_parallel(*args, **kwargs):
            return ["id_a", "id_b", "score", "ratio_name", "ratio_set"]
    
>       monkeypatch.setattr(sim, "_compute_similarity_scores_parallel", fake_parallel)
E       AttributeError: <module 'src.similarity' from '/Users/joe.j/Documents/dev/salesforce/apps/company_junction/src/similarity/__init__.py'> has no attribute '_compute_similarity_scores_parallel'

tests/test_similarity_header_list_regression.py:11: AttributeError
=============================== warnings summary ===============================
tests/perf/test_groups_bench.py:208
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:208: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.performance

tests/perf/test_groups_bench.py:234
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:234: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.performance

tests/perf/test_groups_bench.py:261
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:261: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.performance

tests/perf/test_groups_bench.py:289
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:289: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.performance

tests/perf/test_groups_bench.py:317
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:317: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.performance

tests/perf/test_groups_bench.py:318
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:318: PytestUnknownMarkWarning: Unknown pytest.mark.slow - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.slow

tests/perf/test_groups_bench.py:344
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:344: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.performance

tests/perf/test_groups_bench.py:345
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:345: PytestUnknownMarkWarning: Unknown pytest.mark.slow - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.slow

tests/perf/test_groups_bench.py:375
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:375: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.performance

tests/perf/test_groups_bench.py:404
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:404: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.performance

tests/perf/test_groups_bench.py:437
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:437: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.performance

tests/perf/test_groups_bench.py:472
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/perf/test_groups_bench.py:472: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.performance

tests/test_alias_validation.py:190
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/test_alias_validation.py:190: PytestUnknownMarkWarning: Unknown pytest.mark.slow - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    pytest.param(15000, marks=pytest.mark.slow, id="slow"),

tests/test_cache_keys.py:12
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/test_cache_keys.py:12: PytestUnknownMarkWarning: Unknown pytest.mark.duckdb - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    pytestmark = [pytest.mark.duckdb, pytest.mark.pyarrow]

tests/test_cache_keys.py:12
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/test_cache_keys.py:12: PytestUnknownMarkWarning: Unknown pytest.mark.pyarrow - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    pytestmark = [pytest.mark.duckdb, pytest.mark.pyarrow]

tests/test_duckdb_query_params.py:13
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/tests/test_duckdb_query_params.py:13: PytestUnknownMarkWarning: Unknown pytest.mark.duckdb - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    pytestmark = [pytest.mark.duckdb]

tests/test_disposition_vectorized_phase1353.py::test_vectorized_vs_legacy_identical_output
tests/test_disposition_vectorized_phase1353.py::test_disposition_classification_correctness
tests/test_disposition_vectorized_phase1353.py::test_feature_flag_rollback
tests/test_disposition_vectorized_phase1353.py::test_performance_improvement
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/src/disposition.py:559: UserWarning: This pattern is interpreted as a regular expression, and has match groups. To actually get the groups, use str.extract.
    suspicious_singleton_mask = name_series.str.contains(

tests/test_disposition_vectorized_phase1353.py::test_vectorized_vs_legacy_identical_output
tests/test_disposition_vectorized_phase1353.py::test_disposition_classification_correctness
tests/test_disposition_vectorized_phase1353.py::test_feature_flag_rollback
tests/test_disposition_vectorized_phase1353.py::test_performance_improvement
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/src/disposition.py:841: UserWarning: This pattern is interpreted as a regular expression, and has match groups. To actually get the groups, use str.extract.
    suspicious_singleton_mask = name_series.str.contains(

tests/test_id_utils.py::TestNormalizeSfidSeries::test_normalize_sfid_series_handles_nan
  /Users/joe.j/Documents/dev/salesforce/apps/company_junction/src/utils/id_utils.py:110: FutureWarning: Operation between non boolean Series with different indexes will no longer return a boolean result in a future version. Cast both Series to object type to maintain the prior behavior.
    out.loc[non_empty & is15] = s_filtered[is15].map(sfid15_to_18)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
============================= slowest 20 durations =============================
0.33s call     tests/test_readonly_safety.py::TestReadOnlySafety::test_no_destructive_functions_in_code
0.28s call     tests/test_interrupt_resume.py::TestInterruptResumeIntegration::test_interrupt_resume_workflow
0.24s call     tests/test_readonly_safety.py::TestReadOnlySafety::test_no_direct_run_index_deletions
0.22s call     tests/test_group_stats_memoization.py::TestGroupStatsMemoization::test_duckdb_memoization_smoke
0.20s call     tests/test_disposition_vectorized_phase1353.py::test_performance_improvement
0.12s call     tests/test_env_clamp.py::test_parallel_map_uses_blas_clamp
0.09s call     tests/lints/test_no_schema_fragile_hardcoding.py::TestNoSchemaFragileHardcoding::test_no_hardcoded_is_primary_without_availability_check
0.09s call     tests/lints/test_no_schema_fragile_hardcoding.py::TestNoSchemaFragileHardcoding::test_no_hardcoded_weakest_edge_without_availability_check
0.06s call     tests/contracts/test_parquet_contracts.py::TestLegacyColumnHandling::test_duckdb_handles_missing_legacy_columns
0.04s call     tests/test_scoring_bulk_gate.py::TestScoringBulkGate::test_bulk_gate_cutoff_behavior
0.03s call     tests/lints/test_no_ui_helpers_import.py::test_no_ui_helpers_import
0.03s call     tests/test_cache_keys.py::test_deterministic_pagination
0.03s call     tests/test_parallel_execution.py::test_worker_count_variations
0.02s call     tests/test_parallel_utils.py::TestParallelExecutorChunking::test_balanced_chunking_large_input
0.02s call     tests/test_scoring_threshold_sort.py::TestScoringThresholdSort::test_gate_cutoff_configuration
0.02s call     tests/test_parallel_execution.py::test_parallel_executor_initialization
0.02s call     tests/test_scoring_threshold_sort.py::TestScoringThresholdSort::test_threshold_edge_cases
0.02s call     tests/test_scoring_config_defaults.py::TestScoringConfigDefaults::test_penalty_removal_no_score_drop
0.02s call     tests/test_scoring_config_defaults.py::TestScoringConfigDefaults::test_config_override_defaults
0.02s call     tests/test_scoring_config_defaults.py::TestScoringConfigDefaults::test_gate_cutoff_behavior_change
=========================== short test summary info ============================
SKIPPED [2] tests/test_alias_validation.py:183: TODO: Phase 1.26.1 - Temporarily skipped for QA efficiency, will re-enable after Phase 1.25.1
SKIPPED [1] tests/test_cache_utils.py:177: TODO: Phase 1.26.1 - Update cache utils tests for new path utilities
SKIPPED [1] tests/test_cache_utils.py:199: TODO: Phase 1.26.1 - Update cache utils tests for new path utilities
SKIPPED [1] tests/test_cache_utils.py:221: TODO: Phase 1.26.1 - Update cache utils tests for new path utilities
SKIPPED [1] tests/test_cache_utils.py:241: TODO: Phase 1.26.1 - Update cache utils tests for new path utilities
SKIPPED [1] tests/test_cache_utils.py:265: TODO: Phase 1.26.1 - Update cache utils tests for new path utilities
SKIPPED [1] tests/test_cache_utils.py:288: TODO: Phase 1.26.1 - Update cache utils tests for new path utilities
SKIPPED [1] tests/test_cache_utils.py:309: TODO: Phase 1.26.1 - Update cache utils tests for new path utilities
SKIPPED [1] tests/test_cache_utils.py:330: TODO: Phase 1.26.1 - Update cache utils tests for new path utilities
SKIPPED [1] tests/test_cache_utils.py:343: TODO: Phase 1.26.1 - Update cache utils tests for new path utilities
SKIPPED [1] tests/test_cache_utils.py:370: TODO: Phase 1.26.1 - Update cache utils tests for new path utilities
SKIPPED [1] tests/test_e2e_run_id_and_determinism.py:100: Test input file not found: data/raw/sample_test.csv
SKIPPED [1] tests/test_e2e_run_id_and_determinism.py:183: Test input file not found: data/raw/sample_test.csv
SKIPPED [1] tests/test_e2e_run_id_and_determinism.py:221: Test input file not found: data/raw/sample_test.csv
SKIPPED [1] tests/test_e2e_run_id_and_determinism.py:251: Test input file not found: data/raw/sample_test.csv
SKIPPED [1] tests/test_schema_casing.py:47: Could not test schema casing: [Errno 2] No such file or directory: 'data/processed/latest/group_stats.parquet'
SKIPPED [1] tests/test_schema_casing.py:66: Could not test review_ready schema casing: [Errno 2] No such file or directory: 'data/processed/latest/review_ready.parquet'
SKIPPED [1] tests/test_schema_casing.py:81: Could not test group_details schema casing: [Errno 2] No such file or directory: 'data/processed/latest/group_details.parquet'
ERROR tests/perf/test_groups_bench.py::TestGroupsPageBenchmarks::test_groups_page_10k_pyarrow
ERROR tests/perf/test_groups_bench.py::TestGroupsPageBenchmarks::test_groups_page_10k_duckdb
ERROR tests/perf/test_groups_bench.py::TestGroupsPageBenchmarks::test_groups_page_100k_pyarrow
ERROR tests/perf/test_groups_bench.py::TestGroupsPageBenchmarks::test_groups_page_100k_duckdb
ERROR tests/perf/test_groups_bench.py::TestGroupsPageBenchmarks::test_groups_page_1m_pyarrow
ERROR tests/perf/test_groups_bench.py::TestGroupsPageBenchmarks::test_groups_page_1m_duckdb
ERROR tests/perf/test_groups_bench.py::TestGroupDetailsBenchmarks::test_group_details_10k_pyarrow
ERROR tests/perf/test_groups_bench.py::TestGroupDetailsBenchmarks::test_group_details_10k_duckdb
ERROR tests/perf/test_groups_bench.py::TestSortVariants::test_sort_variants_10k
ERROR tests/perf/test_groups_bench.py::TestFilterVariants::test_filter_variants_10k
FAILED tests/contracts/test_parquet_contracts.py::TestParquetContracts::test_required_columns_exist
FAILED tests/contracts/test_parquet_contracts.py::TestParquetContracts::test_schema_consistency
FAILED tests/contracts/test_parquet_contracts.py::TestParquetContracts::test_column_types
FAILED tests/contracts/test_parquet_contracts.py::TestParquetContracts::test_no_extra_required_columns
FAILED tests/contracts/test_parquet_contracts.py::TestParquetContracts::test_contract_evolution
FAILED tests/contracts/test_parquet_contracts.py::TestHardcodedColumnAssumptions::test_detect_schema_constants_usage
FAILED tests/contracts/test_parquet_contracts.py::TestLegacyColumnHandling::test_duckdb_handles_present_legacy_columns
FAILED tests/contracts/test_parquet_contracts.py::TestLegacyColumnHandling::test_pyarrow_handles_present_legacy_columns
FAILED tests/contracts/test_parquet_contracts.py::TestLegacyColumnHandling::test_conditional_filtering_works_with_present_columns
FAILED tests/lints/test_no_schema_fragile_hardcoding.py::TestNoSchemaFragileHardcoding::test_no_hardcoded_primary_name_in_details_context
FAILED tests/lints/test_no_schema_fragile_hardcoding.py::TestNoSchemaFragileHardcoding::test_no_hardcoded_weakest_edge_without_availability_check
FAILED tests/lints/test_no_schema_fragile_hardcoding.py::TestNoSchemaFragileHardcoding::test_no_hardcoded_is_primary_without_availability_check
FAILED tests/test_alias_matching_parallelism.py::TestAliasMatchingParallelism::test_parallel_executor_integration
FAILED tests/test_cleaning.py::TestCleaning::test_validate_required_columns
FAILED tests/test_cli_builder.py::TestBuildCliCommand::test_build_cli_command_basic
FAILED tests/test_cli_builder.py::TestBuildCliCommand::test_build_cli_command_with_parallelism
FAILED tests/test_cli_builder.py::TestBuildCliCommand::test_build_cli_command_no_parallel
FAILED tests/test_cli_builder.py::TestBuildCliCommand::test_build_cli_command_with_run_control
FAILED tests/test_cli_builder.py::TestBuildCliCommand::test_build_cli_command_with_extra_args
FAILED tests/test_cli_builder.py::TestBuildCliCommand::test_build_cli_command_custom_outdir
FAILED tests/test_details_fast_path.py::TestGroupDetailsDuckDB::test_get_group_details_duckdb_file_not_found
FAILED tests/test_details_fast_path.py::TestGroupsRouting::test_groups_use_duckdb_when_stats_parquet_exists
FAILED tests/test_details_fast_path.py::TestGroupsRouting::test_groups_fallback_to_pyarrow_when_duckdb_unavailable
FAILED tests/test_disposition.py::TestDisposition::test_manual_override_application
FAILED tests/test_disposition.py::TestDisposition::test_multiple_names_verification
FAILED tests/test_duckdb_group_stats_phase1354.py::test_duckdb_memoization - ...
FAILED tests/test_duckdb_group_stats_phase1354.py::test_duckdb_parquet_write
FAILED tests/test_duckdb_group_stats_phase1354.py::test_parquet_size_reporter
FAILED tests/test_duckdb_group_stats_phase1354.py::test_performance_improvement
FAILED tests/test_duckdb_query_params.py::test_no_f_string_sql_queries - Fail...
FAILED tests/test_groups_pagination.py::TestGroupStatsComputation::test_compute_group_stats_no_primary
FAILED tests/test_groups_pagination.py::TestFilterApplication::test_apply_filters_pyarrow_edge_strength
FAILED tests/test_groups_pagination.py::TestPaginationLimits::test_pagination_limits_page_bounds
FAILED tests/test_groups_pagination.py::TestSortingStability::test_sorting_stability_group_id_tiebreaker
FAILED tests/test_import_audit.py::test_import_src_utils - Failed: Failed to ...
FAILED tests/test_imports.py::test_absolute_imports - Failed: Failed to impor...
FAILED tests/test_imports.py::test_utils_imports - Failed: Failed to import u...
FAILED tests/test_interrupt_resume.py::TestInterruptResumeIntegration::test_interrupt_resume_workflow
FAILED tests/test_io_utils.py::test_validate_csv_file - AssertionError: asser...
FAILED tests/test_perf_utils.py::test_track_memory_peak - assert "Memory peak...
FAILED tests/test_perf_utils.py::test_time_stage - assert "Stage 'test_stage'...
FAILED tests/test_readonly_safety.py::TestReadOnlySafety::test_no_destructive_functions_in_code
FAILED tests/test_readonly_safety.py::TestReadOnlySafety::test_maintenance_ui_shows_readonly_copy
FAILED tests/test_readonly_safety.py::TestReadOnlySafety::test_maintenance_rendered_in_sidebar
FAILED tests/test_similarity_header_list_regression.py::test_header_list_raises_typeerror
45 failed, 735 passed, 19 skipped, 25 warnings, 10 errors in 3.98s
